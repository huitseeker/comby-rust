# Those templates are expected to demand significant adjustments to modified code.
# They should probably not be part of an unsupervised workflow (e.g. CI).

[if-continue-filter-neg]
match='for :[var] in :[iter] { if !:[cond] { continue; } :[rest] }'
rewrite='for :[var] in :[iter].iter().filter(|:[var]| :[cond]) {:[rest]}'
[if-let-ok-map]
match='if let Ok(:[var]) = :[opt] { Ok(:[out]) } else { Err(:[e]) }'
rewrite=':[opt].map_or_else(|| :[e], |:[var]| { :[out] })'
rule='where :[var] != :[out]'
[map-unwrap]
match='.map(:[map_pre].unwrap()):[sp].collect:[typ]():[end\n]'
rewrite='.map(:[map_pre]):[sp].collect::<Result<_, _>>()?:[end]'
[runwrap-or-else-backward]
match='match :[target] { Ok(:[var]) => :[var], Err(:[e]) => :[foo], }'
rewrite=':[target].unwrap_or_else(|:[e]| { :[foo] })'
[runwrap-or-else-forward]
match='match :[target] { Err(:[e]) => :[foo], Ok(:[var]) => :[var], }'
rewrite=':[target].unwrap_or_else(|:[e]| { :[foo] })'
[unwrap-or-else-backward]
match='match :[target] { Some(:[var]) => :[var], None => :[foo], }'
rewrite=':[target].unwrap_or_else(|| { :[foo] })'
rule='''
where match :[foo] {
           | ":[_~return .+]" -> false
           | ":[_]" -> true
}
'''
[unwrap-or-else-forward]
match='match :[target] { None => :[foo], Some(:[var]) => :[var], }'
rewrite=':[target].unwrap_or_else(|| { :[foo] })'
rule='''
where match :[foo] {
           | ":[_~return .+]" -> false
           | ":[_]" -> true
}
'''
[zero-range]
match=':[[s]][0..:[[end]]]'
rewrite=':[[s]][..:[[end]]]'
# Those do not work on Iterator traits, but may work on arrays, vecs ...
[iter-any-equals-right]
match='.any(|:[var]| :[var] == :[name])'
rewrite='.contains(:[name])'
[iter-any-equals-left]
match='.any(|:[var]| :[name] == :[var])'
rewrite='.contains(:[name])'
[if-then-some-forward]
match='if :[cond] { Some(:[foo]) } else { None }'
rewrite='(:[cond]).then_some(:[foo])'
[if-then-some-backward]
match='if :[cond] { None } else { Some(:[foo]) }'
rewrite='(!:[cond]).then_some(:[foo])'
[if-let-else-return]
match='if let :[foo](:[pat]) = :[assign] { :[cond1] } else { return :[cond] }'
rewrite='let :[foo](:[pat]) = :[assign] else { return :[cond] }; :[cond1]'
# unwrap_or_default (Rust 1.82+) - Replace match statements that return default values
[unwrap-or-default-option]
match='match :[option] { Some(:[value]) => :[value], None => :[default], }'
rewrite=':[option].unwrap_or_default()'
rule='''
where match :[default] {
| "0" -> true
| "0.0" -> true
| "0.0f32" -> true
| "0.0f64" -> true
| "false" -> true
| "\'\\0\'" -> true
| "String::new()" -> true
| "Vec::new()" -> true
| "HashMap::new()" -> true
| "BTreeMap::new()" -> true
| "HashSet::new()" -> true
| "BTreeSet::new()" -> true
| ":" -> false
}
'''
[unwrap-or-default-result]
match='match :[result] { Ok(:[value]) => :[value], Err(:[_]) => :[default], }'
rewrite=':[result].unwrap_or_default()'
rule='''
where match :[default] {
| "0" -> true
| "0.0" -> true
| "0.0f32" -> true
| "0.0f64" -> true
| "false" -> true
| "\'\\0\'" -> true
| "String::new()" -> true
| "Vec::new()" -> true
| "HashMap::new()" -> true
| "BTreeMap::new()" -> true
| "HashSet::new()" -> true
| "BTreeSet::new()" -> true
| ":" -> false
}
'''
# Option::is_none_or (Rust 1.80) - Replace manual None/Some predicate checks
[option-is-none-or-forward]
match='match :[option] { None => true, Some(:[value]) => :[predicate], }'
rewrite=':[option].is_none_or(|:[value]| :[predicate])'
[option-is-none-or-backward]
match='match :[option] { Some(:[value]) => :[predicate], None => true, }'
rewrite=':[option].is_none_or(|:[value]| :[predicate])'
# Vec::extract_if (Rust 1.86) - Replace filter+retain patterns
[vec-filter-retain]
match='let :[result] = :[vec].iter().filter(|:[item]| :[predicate]).cloned().collect::<Vec<_>>(); :[vec].retain(|:[item]| !:[predicate])'
rewrite='let :[result] = :[vec].extract_if(|:[item]| :[predicate]).collect::<Vec<_>>();'